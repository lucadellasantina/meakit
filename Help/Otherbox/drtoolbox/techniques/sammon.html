<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sammon</title>
  <meta name="keywords" content="sammon">
  <meta name="description" content="SAMMON Performs Sammon's MDS mapping on dataset X">
  <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
    <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # Otherbox --><!-- ../menu.html drtoolbox --><!-- menu.html techniques -->
<h1>sammon
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>SAMMON Performs Sammon's MDS mapping on dataset X</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [y, E] = sammon(x, n, opts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../../brain.png)"><pre class="comment">SAMMON Performs Sammon's MDS mapping on dataset X

    Y = SAMMON(X) applies Sammon's nonlinear mapping procedure on
    multivariate data X, where each row represents a pattern and each column
    represents a feature.  On completion, Y contains the corresponding
    co-ordinates of each point on the map.  By default, a two-dimensional
    map is created.  Note if X contains any duplicated rows, SAMMON will
    fail (ungracefully). 

    [Y,E] = SAMMON(X) also returns the value of the cost function in E (i.e.
    the stress of the mapping).

    An N-dimensional output map is generated by Y = SAMMON(X,N) .

    A set of optimisation options can also be specified using a third
    argument, Y = SAMMON(X,N,OPTS) , where OPTS is a structure with fields:

       MaxIter        - maximum number of iterations
       TolFun         - relative tolerance on objective function
       MaxHalves      - maximum number of step halvings
       Input          - {'raw','distance'} if set to 'distance', X is 
                        interpreted as a matrix of pairwise distances.
       Display        - {'off', 'on', 'iter'}
       Initialisation - {'pca', 'random'}

    The default options structure can be retrieved by calling SAMMON with
    no parameters.

    References :

       [1] Sammon, John W. Jr., &quot;A Nonlinear Mapping for Data Structure
           Analysis&quot;, IEEE Transactions on Computers, vol. C-18, no. 5,
           pp 401-409, May 1969.

    See also : SAMMON_TEST</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../../brain.png)">
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a>	Command window display</li><li><a href="../../../Otherbox/lightspeed/@mutable/display.html" class="code" title="function display(mut)">display</a>	</li><li><a href="../../../Otherbox/m2html/@template/display.html" class="code" title="function display(tpl)">display</a>	TEMPLATE Display a template object in Matlab window</li><li><a href="../../../Otherbox/panel/@panel/display.html" class="code" title="function display(p)">display</a>	disp([10 'panel: (' num2str(p.fig) ', ' int2str(p.id) ')' 10])</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../Otherbox/drtoolbox/Contents.html" class="code" title="">Contents</a>	</li><li><a href="../../../Otherbox/drtoolbox/compute_mapping.html" class="code" title="function [mappedA, mapping] = compute_mapping(A, type, no_dims, varargin)">compute_mapping</a>	COMPUTE_MAPPING Performs dimensionality reduction on a dataset A</li></ul>
</div>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../../brain.png)">
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function d = euclid(x, y)</a></li></ul>
</div>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../../brain.png)"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [y, E] = sammon(x, n, opts)</a>
0002 <span class="comment">%SAMMON Performs Sammon's MDS mapping on dataset X</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%    Y = SAMMON(X) applies Sammon's nonlinear mapping procedure on</span>
0005 <span class="comment">%    multivariate data X, where each row represents a pattern and each column</span>
0006 <span class="comment">%    represents a feature.  On completion, Y contains the corresponding</span>
0007 <span class="comment">%    co-ordinates of each point on the map.  By default, a two-dimensional</span>
0008 <span class="comment">%    map is created.  Note if X contains any duplicated rows, SAMMON will</span>
0009 <span class="comment">%    fail (ungracefully).</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%    [Y,E] = SAMMON(X) also returns the value of the cost function in E (i.e.</span>
0012 <span class="comment">%    the stress of the mapping).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%    An N-dimensional output map is generated by Y = SAMMON(X,N) .</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%    A set of optimisation options can also be specified using a third</span>
0017 <span class="comment">%    argument, Y = SAMMON(X,N,OPTS) , where OPTS is a structure with fields:</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%       MaxIter        - maximum number of iterations</span>
0020 <span class="comment">%       TolFun         - relative tolerance on objective function</span>
0021 <span class="comment">%       MaxHalves      - maximum number of step halvings</span>
0022 <span class="comment">%       Input          - {'raw','distance'} if set to 'distance', X is</span>
0023 <span class="comment">%                        interpreted as a matrix of pairwise distances.</span>
0024 <span class="comment">%       Display        - {'off', 'on', 'iter'}</span>
0025 <span class="comment">%       Initialisation - {'pca', 'random'}</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%    The default options structure can be retrieved by calling SAMMON with</span>
0028 <span class="comment">%    no parameters.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%    References :</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%       [1] Sammon, John W. Jr., &quot;A Nonlinear Mapping for Data Structure</span>
0033 <span class="comment">%           Analysis&quot;, IEEE Transactions on Computers, vol. C-18, no. 5,</span>
0034 <span class="comment">%           pp 401-409, May 1969.</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%    See also : SAMMON_TEST</span>
0037 
0038 <span class="comment">%</span>
0039 <span class="comment">% File        : sammon.m</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% Date        : Monday 12th November 2007.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% Author      : Gavin C. Cawley and Nicola L. C. Talbot</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% Description : Simple vectorised MATLAB implementation of Sammon's non-linear</span>
0046 <span class="comment">%               mapping algorithm [1].</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% References  : [1] Sammon, John W. Jr., &quot;A Nonlinear Mapping for Data</span>
0049 <span class="comment">%                   Structure Analysis&quot;, IEEE Transactions on Computers,</span>
0050 <span class="comment">%                   vol. C-18, no. 5, pp 401-409, May 1969.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% History     : 10/08/2004 - v1.00</span>
0053 <span class="comment">%               11/08/2004 - v1.10 Hessian made positive semidefinite</span>
0054 <span class="comment">%               13/08/2004 - v1.11 minor optimisation</span>
0055 <span class="comment">%               12/11/2007 - v1.20 initialisation using the first n principal</span>
0056 <span class="comment">%                                  components.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% Thanks      : Dr Nick Hamilton (nick@maths.uq.edu.au) for supplying the</span>
0059 <span class="comment">%               code for implementing initialisation using the first n</span>
0060 <span class="comment">%               principal components (introduced in v1.20).</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% To do       : The current version does not take advantage of the symmetry</span>
0063 <span class="comment">%               of the distance matrix in order to allow for easy</span>
0064 <span class="comment">%               vectorisation.  This may not be a good choice for very large</span>
0065 <span class="comment">%               datasets, so perhaps one day I'll get around to doing a MEX</span>
0066 <span class="comment">%               version using the BLAS library etc. for very large datasets.</span>
0067 <span class="comment">%</span>
0068 <span class="comment">% Copyright   : (c) Dr Gavin C. Cawley, November 2007.</span>
0069 <span class="comment">%</span>
0070 <span class="comment">%    This program is free software; you can redistribute it and/or modify</span>
0071 <span class="comment">%    it under the terms of the GNU General Public License as published by</span>
0072 <span class="comment">%    the Free Software Foundation; either version 2 of the License, or</span>
0073 <span class="comment">%    (at your option) any later version.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%    This program is distributed in the hope that it will be useful,</span>
0076 <span class="comment">%    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0077 <span class="comment">%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0078 <span class="comment">%    GNU General Public License for more details.</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%    You should have received a copy of the GNU General Public License</span>
0081 <span class="comment">%    along with this program; if not, write to the Free Software</span>
0082 <span class="comment">%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
0083 
0084 <span class="comment">% This file is part of the Matlab Toolbox for Dimensionality Reduction v0.7.2b.</span>
0085 <span class="comment">% The toolbox can be obtained from http://homepage.tudelft.nl/19j49</span>
0086 <span class="comment">% You are free to use, change, or redistribute this code in any way you</span>
0087 <span class="comment">% want for non-commercial purposes. However, it is appreciated if you</span>
0088 <span class="comment">% maintain the name of the original author.</span>
0089 <span class="comment">%</span>
0090 <span class="comment">% (C) Laurens van der Maaten, 2010</span>
0091 <span class="comment">% University California, San Diego / Delft University of Technology</span>
0092 
0093 
0094     <span class="comment">% use the default options structure</span>
0095     <span class="keyword">if</span> nargin &lt; 3
0096         opts.Display        = <span class="string">'iter'</span>;
0097         opts.Input          = <span class="string">'raw'</span>;
0098         opts.MaxHalves      = 20;
0099         opts.MaxIter        = 500;
0100         opts.TolFun         = 1e-9;
0101         opts.Initialisation = <span class="string">'random'</span>;
0102 
0103     <span class="keyword">end</span>
0104 
0105     <span class="comment">% the user has requested the default options structure</span>
0106     <span class="keyword">if</span> nargin == 0
0107         y = opts;
0108         <span class="keyword">return</span>;
0109     <span class="keyword">end</span>
0110 
0111     <span class="comment">% Create a two-dimensional map unless dimension is specified</span>
0112     <span class="keyword">if</span> nargin &lt; 2
0113         n = 2;
0114     <span class="keyword">end</span>
0115 
0116     <span class="comment">% Set level of verbosity</span>
0117     <span class="keyword">if</span> strcmp(opts.Display, <span class="string">'iter'</span>)
0118         <a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a> = 2;
0119     <span class="keyword">elseif</span> strcmp(opts.Display, <span class="string">'on'</span>)
0120         <a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a> = 1;
0121     <span class="keyword">else</span>
0122         <a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a> = 0;
0123     <span class="keyword">end</span>
0124 
0125     <span class="comment">% Create distance matrix unless given by parameters</span>
0126     <span class="keyword">if</span> strcmp(opts.Input, <span class="string">'distance'</span>)
0127         D = x;
0128     <span class="keyword">else</span>
0129         D = <a href="#_sub1" class="code" title="subfunction d = euclid(x, y)">euclid</a>(x, x);
0130     <span class="keyword">end</span>
0131 
0132     <span class="comment">% Remaining initialisation</span>
0133     N     = size(x, 1);
0134     scale = 0.5 / sum(D(:));
0135     D     = D + eye(N);
0136     Dinv  = 1 ./ D;
0137     <span class="keyword">if</span> strcmp(opts.Initialisation, <span class="string">'pca'</span>)
0138         [UU,DD] = svd(x);
0139         y       = UU(:,1:n)*DD(1:n,1:n);
0140     <span class="keyword">else</span>
0141         y = randn(N, n);
0142     <span class="keyword">end</span>
0143     one   = ones(N,n);
0144     d     = <a href="#_sub1" class="code" title="subfunction d = euclid(x, y)">euclid</a>(y,y) + eye(N);
0145     dinv  = 1./d;
0146     delta = D - d;
0147     E     = sum(sum((delta.^2).*Dinv));
0148 
0149     <span class="comment">% Get on with it</span>
0150     <span class="keyword">for</span> i=1:opts.MaxIter
0151 
0152         <span class="comment">% Compute gradient, Hessian and search direction (note it is actually</span>
0153         <span class="comment">% 1/4 of the gradient and Hessian, but the step size is just the ratio</span>
0154         <span class="comment">% of the gradient and the diagonal of the Hessian so it doesn't</span>
0155         <span class="comment">% matter).</span>
0156         delta    = dinv - Dinv;
0157         deltaone = delta * one;
0158         g        = delta * y - y .* deltaone;
0159         dinv3    = dinv .^ 3;
0160         y2       = y .^ 2;
0161         H        = dinv3 * y2 - deltaone - 2 * y .* (dinv3 * y) + y2 .* (dinv3 * one);
0162         s        = -g(:) ./ abs(H(:));
0163         y_old    = y;
0164 
0165         <span class="comment">% Use step-halving procedure to ensure progress is made</span>
0166         <span class="keyword">for</span> j=1:opts.MaxHalves
0167             y(:) = y_old(:) + s;
0168             d     = <a href="#_sub1" class="code" title="subfunction d = euclid(x, y)">euclid</a>(y, y) + eye(N);
0169             dinv  = 1 ./ d;
0170             delta = D - d;
0171             E_new = sum(sum((delta .^ 2) .* Dinv));
0172             <span class="keyword">if</span> E_new &lt; E
0173                 <span class="keyword">break</span>;
0174             <span class="keyword">else</span>
0175                 s = 0.5*s;
0176             <span class="keyword">end</span>
0177         <span class="keyword">end</span>
0178 
0179         <span class="comment">% Bomb out if too many halving steps are required</span>
0180         <span class="keyword">if</span> j == opts.MaxHalves
0181             warning(<span class="string">'MaxHalves exceeded. Sammon mapping may not converge...'</span>);
0182         <span class="keyword">end</span>
0183 
0184         <span class="comment">% Evaluate termination criterion</span>
0185         <span class="keyword">if</span> abs((E - E_new) / E) &lt; opts.TolFun
0186             <span class="keyword">if</span> <a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a>
0187                 fprintf(1, <span class="string">'Optimisation terminated - TolFun exceeded.\n'</span>);
0188             <span class="keyword">end</span>
0189             <span class="keyword">break</span>;
0190         <span class="keyword">end</span>
0191 
0192         <span class="comment">% Report progress</span>
0193         E = E_new;
0194         <span class="keyword">if</span> <a href="../../../IO/mcd/mcintfac/@datastrm/display.html" class="code" title="function display(d)">display</a> &gt; 1
0195             fprintf(1, <span class="string">'epoch = %d : E = %12.10f\n'</span>, i, E * scale);
0196         <span class="keyword">end</span>
0197     <span class="keyword">end</span>
0198 
0199     <span class="comment">% Fiddle stress to match the original Sammon paper</span>
0200     E = E * scale;
0201 <span class="keyword">end</span>
0202 
0203 <a name="_sub1" href="#_subfunctions" class="code">function d = euclid(x, y)</a>
0204     d = sqrt(sum(x.^2,2)*ones(1,size(y,1))+ones(size(x,1),1)*sum(y.^2,2)'-2*(x*y'));
0205 <span class="keyword">end</span>
0206</pre></div>
<hr><address>Copyright (C) 2008-2010 Pu Jiangbo @ Britton Chance Center for Biomedical Photonics<br/>Generated on Fri 22-Jun-2012 16:47:48</address>
</body>
</html>