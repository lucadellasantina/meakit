function [ ch_state ] = util_plot_channel_of_state( network_vectors, seq, clu_sub, threshold, method, varargin )
%UTIL_PLOT_CHANNEL_OF_STATE Visualize the network states by showing
%channels participating in each state. This function will also do the
%hierarchical clustering results of these channels and their states.
%
%   Input:
%           network_vector:     Network activity vectors (elecs * bins)
%           seq:                The channel sequence indexer for
%                               network_vector (very important when you
%                               pickoff some 'inactive' channels).
%           clu_sub:            The clustering results, generated by
%                               util_extract_cluster. Through this, each
%                               bin is assigned to a clustered state.
%           threshold:          The threshold for determining whether the
%                               electrode is participating. 
%                               [default]: 1. You may increase it with your
%                               bin length (1:1000 ms), if = 0, channels
%                               with few firings can be counted.
%           method:             Visualization method.
%                               'dots': Plot an 8*8 dots graph showing each
%                                       state's own electrodes.
%                               'hier': Hierarchical clustering results.
%           subplots:            If true, 'dots' will be ploted in one
%                               chart. [default]: false.
%           hp:                 p-value in hierarchical clustering.
%                               [default] is autofit. Recommend - 0
%           axisoff:            Don't display axis in hierarchical
%                               clustering. [default]: true
%           colored:            Colored hierarchical clustering results.
%                               [default]: false
%           
%   Output:
%           ch_state:           A structure array.
%                               ch_state.c1.electrodes = all electrodes
%                               participated in state cluster 1.
%                               ch_state.c1.bins = all bins in state 1.
%
%   Example:
%           [ ch_state ] = util_plot_channel_of_state( network_vectors,
%           seq, subscript, 2, 'dots', 'subplots', 1 );
%           [ ch_state ] = util_plot_channel_of_state( network_vectors,
%           seq, subscript, 2, 'hier', 'hp', 0);
%
%   Created on Jul/28/2010 By Pu Jiangbo
%   Britton Chance Center for Biomedical Photonics
%
%   $Revision:
%       PJB#2010-07-29  Correcting the wrong hierarchical clustering
%                       inputs, the channel id should not be appeared in
%                       the input of pdist. We should use the permutation
%                       index from dendrogram to get the correct channel
%                       layout.

pvpmod(varargin);

if ~exist('subplots', 'var')
    subplots = false;
end

if ~exist('axisoff', 'var')
    axisoff = true;
end

if ~exist('colored', 'var')
    colored = false;
end

% Convert structure to vector
clu_vec = util_convert_struct_2_vector_cluster(clu_sub);

% Find number of clusters
num_cluster = max(clu_vec);
num_points = length(clu_vec);

% Loop
for i = 1:num_cluster
    % Init
    ch_state.(['c' num2str(i)]).electrodes = [];
    ch_state.(['c' num2str(i)]).bins = (clu_vec == i);
    
    % Collect bins in this state
    state_bins = network_vectors(:, ch_state.(['c' num2str(i)]).bins);
    
    % Collect participated channels
    for j = 1:size(state_bins, 2)
        if threshold == 0
            ch = seq(state_bins(:, j) > threshold);
        else
            ch = seq(state_bins(:, j) >= threshold);
        end
        ch_state.(['c' num2str(i)]).electrodes = unique([ch_state.(['c' num2str(i)]).electrodes util_convert_hw2ch(ch)]);
    end
end

% Visualization
% Prepare colors
colors = jet(num_cluster);

if strcmpi(method, 'dots')
    if subplots
        figure
    end
    for clu = 1:num_cluster
        % Prepare scatter
        sc_x = zeros(64, 1);
        sc_y = zeros(64, 1);
        sc_f = zeros(64, 3);    % Facecolor
        s = 1;
        for i = 1:8
            for j = 1:8
                sc_x(s) = i;
                sc_y(s) = j;
                if i==1&&j==1 || i==1&&j==8 || i==8&&j==1 || i==8&&j==8
                    % Corner
                    sc_f(s, :) = [1 1 1];
                elseif util_find_a_in_b(i*10+j, ch_state.(['c' num2str(clu)]).electrodes)
                    % Participated
                    sc_f(s, :) = colors(clu, :);
                else
                    % Not participated
                    sc_f(s, :) = [1 1 1];
                end
                s = s + 1;
            end
        end
        
        if subplots
            subplot(1, num_cluster, clu)
        else
            figure
        end
        
        % Do job
        scatter(sc_x, sc_y, 200, sc_f, 'filled', 'MarkerEdgeColor', [0 0 0]);
        
        % Erase four corners
        hold on, scatter([1 1 8 8], [1 8 1 8], 200, 'MarkerFaceColor', [1 1 1], 'MarkerEdgeColor', [1 1 1]), hold off
        % Label four corners
        adj = 0.1;
        text(1 - adj, 1, '11'); text(1 - adj, 8, '18'); text(8 - adj, 1, '81'); text(8 - adj, 8, '88');
        
        % Title / Label / Axis
        axis ij;
        xlim([0 9]); set(gca, 'XTick', []); set(gca, 'XColor', [1 1 1]);
        ylim([0 9]); set(gca, 'YTick', []); set(gca, 'YColor', [1 1 1]);
        title(['State ' num2str(clu)]);
    end
elseif strcmpi(method, 'hier')
    % Prepare the Hierarchical Clustering
    hier_pair = [];
    for i = 1:num_cluster
        for j = 1:length(ch_state.(['c' num2str(i)]).electrodes)
            hier_pair = [hier_pair; [ch_state.(['c' num2str(i)]).electrodes(j) i]];
        end
    end
    
    % Remove redundant electrodes 
    % (elec: state1 state2 state3), not (elec1:state1, elec1:state2)
    maxlength = 0;
    for i = 1:length(seq)
        chid = util_convert_hw2ch(seq(i));
        hier_pair_struct.(['e' num2str(chid)]).states = [];
        for j = 1:num_cluster
            if util_find_a_in_b(chid, ch_state.(['c' num2str(j)]).electrodes)
                hier_pair_struct.(['e' num2str(chid)]).states = [hier_pair_struct.(['e' num2str(chid)]).states j];
            end
        end
        if length(hier_pair_struct.(['e' num2str(chid)]).states) > maxlength
            maxlength = length(hier_pair_struct.(['e' num2str(chid)]).states);
        end
    end
    
    % Convert to array
    hier_pair_array = zeros(length(seq), maxlength + 1);
    for i = 1:length(seq)
        chid = util_convert_hw2ch(seq(i));
        hier_pair_array(i, 1) = chid;
        contents = hier_pair_struct.(['e' num2str(chid)]).states;
        hier_pair_array(i, 2:(length(contents) + 1)) = contents;
    end
    
    % Generate observation labels
    obs_labels = {};
    for i = 1:length(seq)
        obs_labels = [obs_labels, {num2str(hier_pair_array(i, 1))}];
    end
    
    % Separate channel list
    ch_list = hier_pair_array(:, 1);
    hier_pair_array(:, 1) = [];
    
    distance = pdist(hier_pair_array, 'seuclidean');
    linkages = linkage(distance, 'average');
    if ~exist('hp', 'var')
        figure, subplot(2,1,1), [H, T, perm] = dendrogram(linkages, 'colorthreshold', 'default', 'labels', obs_labels);
        warning('UTIL:PARAM', 'hp is autofit, it may be wrong.')
    else
        figure, subplot(2,1,1), [H, T, perm] = dendrogram(linkages, hp, 'colorthreshold', 'default', 'labels', obs_labels);
        if hp ~= 0
            warning('UTIL:PARAM', 'Not all leaves are showed, the arrangement of the electrodes may be wrong.');
        end
    end
    
    if axisoff
        axis off;
    end
    
    if ~colored
        set(H, 'Color', [0 0 0])
    end
    
    % Prepare the electrode plot
    hier_im = zeros(num_cluster, length(seq));
    
    % Fill the image
    % Color is determined by states
    % Position is determined by hierarchical clustering results
    ch_pos = [];
    for i = 1:length(perm)
        ch_pos = [ch_pos find(T == perm(i))'];
    end
    ch_pos = ch_list(ch_pos);
    
    for i = 1:num_cluster
        for j = 1:length(seq)
            if util_find_a_in_b(ch_pos(j), ch_state.(['c' num2str(i)]).electrodes)
                hier_im(i, j) = i;
            else
                hier_im(i, j) = 0;
            end
        end
    end
    
    % Add color for 0
    colors = [1 1 1; colors];
    
    % Plot
    subplot(2,1,2), imagesc(hier_im), colormap(colors);
    
    % Label & Ticks
    xlabel('Channel #');
    set(gca, 'XTick', [0.5:(length(seq)-0.5)]); set(gca, 'XTickLabel', num2str(ch_pos(:)));
    set(gca, 'YTick', [0.5:(num_cluster-0.5)]);
    yticklabel = {};
    for i = 1:num_cluster
        yticklabel = [yticklabel {['State ' num2str(i)]}];
    end
    set(gca, 'YTickLabel', yticklabel);
    
    % Grid
    grid on; set(gca, 'GridLineStyle', '-');
else
    error('Not suppoerted yet.');
end


end
